---
title: "Analysis of Kyiv Road Traffic Using Uber Movement Data"
description: "This analysis uses Uber Movement speed data to analyze traffic of Kyiv, Ukraine. By looking at the speed data, we are able to find traffic flow's bottlenecks, as well as see the impact of COVID-19-related measures on the city traffic"
slug: uber-movement-kyiv
author:
  - name: Taras Kaduk
    url: https://taraskaduk.com
date: 2020-10-14
output:
  distill::distill_article:
    self_contained: false
    toc: true
    toc_depth: 2
bibliography: bibliography.bib
draft: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE,
	include=FALSE
)
```

```{r libs}
library(gifski)
library(sf)
library(osmdata)
library(lubridate)
library(gganimate)
library(tidyverse)
library(extrafont)
```

```{r theme}
source(Sys.getenv("THEME"))
caption <- "Source: Uber Movement\nMethods and analysis: taraskaduk.com"
```

## Introduction
The COVID-19 pandemic has impacted many areas of life far beyond human health. It has already had a major impact of economy, ecology, education, technology, finance etc - all too many to enumerate. It will remain a phenomenon that scientists will study for decades to come. 

Among some of the impacted domains is the urban life, and in particular - how do the COVID-19-related restrictions alter city traffic and congestion. Plenty of research in this area has already been done [@romei2020real], [@plumer_traffic_2020], [@geotab_data__analytics_team_impact_2020], [@wang_impact_2020], [@abu-rayash_analysis_2020]. One of the most prominent features of such analyses, however, is that the data used in them is either proprietary, exists behind a paywall or a "freemium"-type arrangement, or is pre-aggregated.

In this article, I will attempt to examine the impact of COVID-19-related restrictions of city traffic using the data that is available for free: (Uber Movement traffic data)[https://movement.uber.com/]

## Data, Materials, Methods
As mentioned above, for this analysis, I used data provided by Uber Movement [@uber_technologies_inc_uber_2020]. Other data sources, such as [TomTom Historical Traffic Stats](https://www.tomtom.com/products/historical-traffic-stats/), on which more elaborate traffic studies are based [@tomtom_nv_helsinki_2020] [@romei2020real], exists. However, obtaining such data points are often associated with pay walls of "freemium" developer accounts, which is completely understandable, yet which at the same time complicates the progress of citizen data science. 

The benefit of working with Uber Movement data is its free availability. The downside is in the limits of traffic data's availability: at the time of this writing in October 2020, some Uber Movement data is available for only 60 cities worldwide and mostly up through 2020-03-31.

### Initial Data
Obtaining the data can be done via [NPM Uber Movement Data Toolkit](https://www.npmjs.com/package/movement-data-toolkit), or directly from https://movement.uber.com/ as `.csv` files.

The streets data contains multiple road segments each several meters long and identified by OSM IDs: way ID, start node ID, end node ID. An additional step was taken to only include road segment within administrative city boundaries.

```{r streets-import, cache = TRUE}
# Kyiv geometry -----------------------------------------------------------

place <- "Kyiv Ukraine"

boundary <- opq(place) %>%
  add_osm_feature(key = "boundary", 
                  value = c("administrative")) %>%
  osmdata_sf() %>% 
  osmdata::unname_osmdata_sf() %>% 
  .$osm_multipolygons %>% 
  filter(osm_id == 421866) %>% 
  dplyr::select()

water_osm <- opq(place) %>%
  add_osm_feature(key = "natural", value = "water") %>%
  osmdata_sf() %>% 
  unname_osmdata_sf()

river_osm <- opq(place) %>%
  add_osm_feature(key = "waterway", value = c("river", "riverbank")) %>%
  osmdata_sf() %>% 
  unname_osmdata_sf()

water <- c(water_osm, river_osm) %>% 
  .$osm_multipolygons %>% 
  select(osm_id, name) %>% 
  mutate(area = st_area(.)) %>% 
  filter(area >= quantile(area, probs = 0.75)) %>% 
  st_buffer(0) %>% 
  st_intersection(boundary)


# Streets --------------------------------
streets_osm_import <- opq(place) %>%
  add_osm_feature(key = "highway", 
                  value = c("motorway", "primary", "motorway_link", "primary_link",
                            "secondary", "tertiary", "secondary_link", "tertiary_link")) %>%
  osmdata_sf()

streets_osm <- streets_osm_import$osm_lines %>% 
  select(osm_id, name, name.en, highway, maxspeed, oneway, surface) %>% 
  mutate(length = as.numeric(st_length(.)))

# Segments -----------------------------------------------------------

# This the CLI command for pulling geometries; 
#   $ mdt create-geometry-file kyiv 2020 --output="kyiv.geojson"
streets_import <- st_read("data/kyiv.geojson") %>% 
  # See https://community.rstudio.com/t/why-does-st-transform-re-set-coordinates-to-0-0/82430
  # for why setting CRS to 4326
  st_set_crs(4326)

streets_filtered <- streets_import %>% 
  # filter(osmhighway %in% c("primary", "primary_link", 
  #                          "secondary", "secondary_link",
  #                          "tetriary", "tertiary_link")) %>% 
  st_intersection(boundary)

streets <- streets_filtered %>% 
  rename(osm_start_node_id = osmstartnodeid,
         osm_end_node_id = osmendnodeid,
         osm_way_id = osmwayid)

segments <- streets %>% 
  select(osm_way_id, osm_start_node_id, osm_end_node_id)
st_geometry(segments) <- NULL
segments <- segments %>% 
  distinct(.keep_all = TRUE) %>% 
  mutate(index = row_number())

streets <- streets %>% 
  inner_join(segments, by=c("osm_way_id", "osm_start_node_id", "osm_end_node_id"))

streets_lengths <- streets %>% 
  select(index) %>% 
  mutate(length = st_length(.) %>% as.numeric(),
         length = length/1000)
st_geometry(streets_lengths) <- NULL

```

As far as speed data, Uber Movement can provide daily data on an "hour" grain level for the above mentioned road segments. Variables provided are mean speed and speed standard deviation. To summarize, each observation includes mean speed and standard deviation for a particular short road segment on a specific hour of a specific day.


```{r speeds, cache.lazy = FALSE, cache=TRUE}
# Speed data --------------------------------------------------------------
speeds_import <- readRDS("data/kyiv_speeds_2020.RDS")

speeds <- speeds_import %>% 
  inner_join(segments, by = c("osm_way_id", "osm_start_node_id", "osm_end_node_id")) %>% 
  inner_join(streets_lengths, by = "index") %>% 
  mutate(time = length/speed_kph_mean,
         timestamp = with_tz(utc_timestamp, tzone = "Europe/Kiev")) %>% 
  select(-c(utc_timestamp,osm_way_id, osm_start_node_id, osm_end_node_id))
  
mean_speed <- mean(speeds$speed_kph_mean)

covid <- as.Date("2020-03-12")

```



### Data Transformation
To get the final metric of traffic delay (expressed as a %), a series of data transformation steps was taken:

- each segment's length was obtained from the geometry data;
- given each segment's length and mean speed, average travel was obtained;
- for every segment, using daytime weekend data^[Nighttime data was avoided due to an increased probability of excessive speeding, which would skew the data. Instead, weekend daytime speeds were analyzed to establish the benchmark], maximum speed was obtained for every Saturday and Sunday, and the mean of these maximum weekend daytime speeds was established as segment's benchmark speed.
- with maximum speeds available, "best time" was calculated for every observation, and the difference between actual travel time and "best time" constituted a time delay. 
- in every subsequent grouping and aggregation, delays and "best" times would be summed up, and diving total delay time by total "best time" produced the final metric.

```{r speeds-transform, cache.lazy=FALSE, cache = TRUE}
speeds_max <- speeds %>% 
  filter(wday(timestamp) %in% c(1,7) & 
           hour(timestamp) >= 6 &
           hour(timestamp) <= 22
           ) %>% 
  mutate(date = date(timestamp)) %>% 
  group_by(index, date) %>% 
  summarise(max_speed = max(speed_kph_mean)) %>% 
  ungroup() %>% 
  group_by(index) %>% 
  summarise(max_speed = mean(max_speed) %>% round(2)) %>% 
  ungroup()

speeds_delay <- speeds %>% 
  inner_join(speeds_max, by = "index") %>% 
  mutate(best_time = if_else(max_speed < speed_kph_mean, time, length/max_speed),
         delay = time - best_time)
```


```{r boundaries}

    
center <- c(long = 30.5224974,
            lat = 50.4508911)
  
dist <- c(12500, 7500)


circle1 <- tibble(lat = center["lat"], long = center["long"]) %>% 
  st_as_sf(coords = c("long", "lat"),crs = 4326) %>%  
  st_transform(3857) %>% 
  st_buffer(dist = dist[1]) %>% 
  st_transform(4326)

circle2 <- tibble(lat = center["lat"], long = center["long"]) %>% 
  st_as_sf(coords = c("long", "lat"),crs = 4326) %>%  
  st_transform(3857) %>% 
  st_buffer(dist = dist[2]) %>% 
  st_transform(4326)

```


## Results

### Typical traffic patters

From the most recent available data set from January 1, 2020 to March 31, 2020, 2 months between January 12 and March 12 can be used to display the recent typical traffic: January 1-7 are holidays and March 12 through the end of the data set were the dates under COVID-19 quarantine.

The typical traffic in Kyiv has all expected attributes of any large city: increased congestion during week days, especially during rush hours.

```{r wday-delay,  fig.asp=5/4}
speeds_wday <- speeds_delay %>% 
  filter(date(timestamp) >= date("2020-01-12") & 
           date(timestamp) < date("2020-03-12")) %>% 
  mutate(date = date(timestamp),
         wday = wday(date, label = TRUE, abbr=FALSE),
         hour = hour(timestamp)) %>% 
  group_by(wday, hour) %>% 
  summarise(distance = sum(length),
            time = sum(time),
            best_time = sum(best_time),
            delay = sum(delay)) %>% 
  ungroup() %>% 
  mutate(delay_pct = delay / best_time)

ggplot(speeds_wday, aes(x=hour, y=delay_pct, col = "")) + 
  geom_smooth(se=FALSE, span = 0.2) +
  facet_wrap(~wday, ncol=2)+
  scale_x_continuous(breaks=c(8,18),
                     labels = c("8:00", "18:00"))+
  scale_y_continuous(labels = scales::percent_format(accuracy = 1),
        breaks = c(0,0.25,0.5,0.75,1))+
  theme(legend.position = "none")+
  scale_color_tk()+
  labs(title = toupper("Typical Kyiv city traffic delays"),
       subtitle = "By day of the week and hour of the day",
       caption = caption)
```

Spatially, a typical weekday traffic flow can be visualized in the following manner:

```{r hourly, include=FALSE}

# Hourly by street --------------------------------------------------------

speeds_bystreet_byhour <- speeds_delay %>% 
  filter(date(timestamp) >= date("2020-01-12") & 
           date(timestamp) < date("2020-03-12") &
           wday(timestamp) != 1 &
           wday(timestamp) != 7) %>% 
  mutate(hour = hour(timestamp)) %>% 
  group_by(index, hour) %>% 
  summarise(distance = sum(length),
            time = sum(time),
            best_time = sum(best_time),
            delay = sum(delay),
            speed_mean = mean(speed_kph_mean)) %>% 
  ungroup() %>% 
  mutate(speed = distance / time,
         delay_pct = delay / best_time)

speeds_check <- speeds_bystreet_byhour %>% 
  group_by(index) %>% 
  tally() %>% 
  ungroup() %>% 
  filter(n>=6) %>% 
  select(-n) %>% 
  merge(tibble(hour = c(0:23)), all=TRUE)

speeds_expanded <- speeds_check %>%  
  left_join(speeds_bystreet_byhour, by=c("index", "hour")) %>% 
  replace_na(list(delay_pct = 0))

speeds_expanded_geo <- speeds_expanded %>% 
  inner_join(streets, by = "index") %>% 
  st_as_sf()
```


```{r animation, eval=TRUE, include=FALSE}
# Daily animation ---------------------------------------------------------

hours <- c(0:23)
boundaries <- list(circle2 = circle2, circle1=circle1, full=boundary)
options <- c("circle2", "circle1", "full")


gif_plot <- function(df, name){
  png_files <- NULL
  for (h in hours){
    ggplot()+
      geom_sf(data = df, fill="#253441")+
      geom_sf(data = water %>% 
                st_intersection(df),
              fill = "#3C5368",
              # size = .8,
              lwd = 0) +
      geom_sf(data= streets_filtered %>% 
                st_intersection(df),
              col="#3B5268", 
              size=0.1) +
      geom_sf(data= speeds_expanded_geo %>% 
                st_intersection(df) %>% 
                filter(hour == h), 
              aes(geometry = geometry,
                  col=delay_pct), 
              size=0.4) +
      scale_colour_viridis_c(
        labels = scales::percent_format(accuracy = 1),
        breaks = c(0.25,0.5,1,2.5),
        #trans = "sqrt",
        na.value = "grey50",
        guide = "coloursteps",
        option = "magma",
        limits = c(0, 2.5), 
        oob = scales::squish,
        direction = -1) +
      labs(title = toupper(paste0("Kyiv city traffic delay, ", str_pad(h,2,"left",0),":00")),
           caption = caption,
           color = "Traffic Delay, %") +
      theme(legend.text = element_text(size = 6),
            axis.line = element_blank(),
            axis.text = element_blank(),
            panel.grid.major = element_blank())
    
    frame <- paste0("temp/",name,"-", str_pad(h,2,"left",0),".png")
    ggsave(frame)
    png_files <- c(png_files, frame)
  }
    gif_file <- gifski(png_files, gif_file=paste0("temp/",name,".gif"), width=2100, height=2100)
    unlink(png_files)
}
# $ gifski --quality 100 --width 2595 --fps 2 -o full.gif full*.png

gif_plot(df=circle2,name="circle2")
gif_plot(df=circle2,name="circle2")
gif_plot(df=boundary,name="boundary")
```

The most problematic segments during rush hour can be visualized as follows:

```{r}
plot_speeds2 <- plot_speeds %>% 
  filter(delay_pct > 2) %>% 
  filter(hour %in% c(8,18)) 

ggplot()+
  geom_sf(data=plot_boundary, fill="#253441")+
  geom_sf(data = plot_water,
          fill = "#3C5368",
          # size = .8,
          lwd = 0) +
  geom_sf(data= plot_streets,
          col="#3B5268", 
          size=0.1) +
  geom_sf(data=plot_speeds2,
          aes(geometry = geometry,
              col=delay_pct), 
          size=0.4) +
  scale_colour_gradient(labels = scales::percent_format(accuracy = 1),
    # breaks = c(0.25,0.5,1,2.5),
    #trans = "sqrt",
    # guide = "coloursteps",
    # option = "magma",
    #direction = -1,
    low = "#EC838A",
    high = deframe(colors)["Red"],
    na.value = "grey50") +

  labs(title = toupper(paste0("Kyiv city traffic delay, ", str_pad(h,2,"left",0),":00")),
       caption = caption,
       color = "Traffic Delay, %") +
  facet_wrap(~hour) +
  theme(legend.text = element_text(size = 6),
        axis.line = element_blank(),
        axis.text = element_blank(),
        panel.grid.major = element_blank())
```






```{r}
speeds_bydayhour <- speeds_delay %>% 
  mutate(hour = hour(timestamp),
         date = date(timestamp)) %>% 
  group_by(date, hour) %>% 
  summarise(distance = sum(length),
            time = sum(time),
            best_time = sum(best_time),
            delay = sum(delay),
            speed_mean = mean(speed_kph_mean)) %>% 
  ungroup() %>% 
  mutate(speed = distance / time,
         delay_pct = delay / best_time)
```


- Busiest roads (not segments)
- Busiest roads bar chart
- COVID impact:
  - tile chart
  - line chart (delay pct over time)
  - delay by weekday line chart (comparison)





```{r, layout="l-body-outset", fig.width=8, include=TRUE}
ggplot(speeds_bydayhour, aes(x=date, y=hour, fill=delay_pct)) +
  geom_tile() +
  geom_vline(xintercept=covid,
             linetype = 3) +
  annotate("label", x = covid, y = 25, 
           label = "COVID-19 quarantine",
           label.size=NA,
           fill="#F3F6F7") +
  scale_fill_viridis_c(
        labels = scales::percent_format(accuracy = 1),
        breaks = c(0.25,0.5,1,2.5),
        na.value = "grey50",
        guide = "coloursteps",
        option = "magma",
        direction = -1) +
  scale_y_continuous(breaks = c(0,8,18,23), 
                     labels = c("00:00", "8:00", "18:00", "23:00")) +
  scale_x_date(date_labels = "%b %d",
               date_breaks = "1 month"
               ) +
  theme(axis.title = element_blank(),
        # legend.position="right",
        # legend.text = element_text(size = 10),
        panel.grid.minor = element_blank()) +
  coord_equal() +
  labs(title = toupper(paste0("Kyiv city traffic delay by hour of the day")),
           caption = caption,
           fill = "Traffic Delay, %")
```



## Discussion